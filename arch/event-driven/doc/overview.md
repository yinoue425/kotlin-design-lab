# イベント駆動アーキテクチャ: ブローカー vs メディエータ vs ワーカー

## 概要

イベント駆動アーキテクチャの代表的な3つのパターンを、同じ「注文処理」ユースケースで実装し比較する。

- **ブローカー** — 中央のイベントバスがメッセージを転送するだけ。ビジネスロジックは各購読者に分散（fan-out）
- **メディエータ** — 中央のメディエータがワークフローを制御。処理順序・分岐をメディエータが決定（オーケストレーション）
- **ワーカー** — タスクキューから複数ワーカーが競合取得して処理。各タスクは1つのワーカーだけが処理（competing consumers）

## パターン比較

| 観点 | ブローカー | メディエータ | ワーカー |
|---|---|---|---|
| イベント配信モデル | 全購読者に配信（fan-out） | メディエータが順序制御 | 1タスク = 1ワーカーが取得 |
| 処理主体 | 各Subscriberが独立処理 | メディエータが逐次呼び出し | ワーカープールが並列処理 |
| 中央コンポーネントの役割 | ルーティングのみ（ダム） | ワークフロー制御（スマート） | タスク保持（キュー） |
| コンポーネント間の結合度 | ゼロ | メディエータ経由で間接結合 | ゼロ（キュー経由で疎結合） |
| 処理順序 | 不定（並列可） | メディエータが明示的に制御 | 不定（ワーカーの空き順） |
| エラー時の挙動 | 各購読者が独立処理 | メディエータが後続処理を短絡 | 個々のワーカーが独立処理 |
| スケーラビリティ | 購読者を追加 | メディエータがボトルネック | ワーカー数を増やすだけ |
| 適するケース | 通知、ログ、分析など独立処理 | 順序のある業務フロー、サガ | 大量タスクの並列分散処理 |
| 実世界の例 | Kafka Consumer Group | BPMN エンジン | Sidekiq, Celery, SQS + Lambda |

## 実行方法

```bash
cd arch/event-driven

# ビルド & テスト
./gradlew build

# ブローカーパターンのデモ
./gradlew :broker:run

# メディエータパターンのデモ
./gradlew :mediator:run

# ワーカーパターンのデモ
./gradlew :worker:run
```

## 技術スタック

| カテゴリ | 選定 |
|---|---|
| 言語 | Kotlin 2.2.0 |
| ビルド | Gradle 8.14.2 (Kotlin DSL) |
| JVM | Java 21 |
| テスト | kotlin.test + JUnit 5 |
| 外部ライブラリ | なし（標準ライブラリのみ） |
